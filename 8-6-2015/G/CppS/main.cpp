// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "UserService.h"
#include "DataProvider.h"
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>
#include <iostream>
#include "Poco/LRUCache.h"
#include "Poco/Util/ServerApplication.h"
#include "Poco/Util/Option.h"
#include "Poco/Util/OptionSet.h"
#include "Poco/Util/HelpFormatter.h"
#include "Poco/Task.h"
#include "Poco/TaskManager.h"
#include "Poco/DateTimeFormatter.h"
#include <iostream>


using Poco::Util::Application;
using Poco::Util::ServerApplication;
using Poco::Util::Option;
using Poco::Util::OptionSet;
using Poco::Util::OptionCallback;
using Poco::Util::HelpFormatter;
using Poco::Task;
using Poco::TaskManager;
using Poco::DateTimeFormatter;

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace apache::thrift::concurrency;
using boost::shared_ptr;
using Poco::LRUCache;
using namespace std;
using namespace ::Common::ThriftInterface;

class UserServiceHandler : virtual public UserServiceIf {
private:
    int i;
    LRUCache<string, User> *myCache; // cache with LRU
public:

    UserServiceHandler() {
        // Your initialization goes here
        myCache = new LRUCache<string, User>(20);
    }

    void GetUser(User& _return, const std::string& username) {
        // Your implementation goes here
        DataProvider data;
        if (myCache->get(username).isNull()) {
            try {
                data.GetUsers(_return, username);
            } catch (Poco::Exception ex) {
                DataProvider::logger.error(ex.message());
            }
            myCache->add(username, _return);
        } else {
            Poco::SharedPtr<User> pt = myCache->get(username);
            _return = *pt;
        }
    }

    int32_t UpdateVisitor(const std::string& username) {
        // Your implementation goes here
        DataProvider data;
        try {
            int n = data.UpdateVisitor(username);
            return n;
        } catch (Poco::Exception ex) {
            DataProvider::logger.error(ex.message());
        }
        return -1;
    }

    void Increase(User& _return, const std::string& username) {
        // Your implementation goes here
        DataProvider data;
        try {
            data.Increase(_return, username);
        } catch (Poco::Exception ex) {
            DataProvider::logger.error(ex.message());
        }
    }

    bool CheckLogin(const std::string& username, const std::string& pword) {
        // Your implementation goes here
        printf("CheckLogin\n");
        return true;
    }
};

void SimpleServer(shared_ptr<TProcessor> processor, shared_ptr<TServerTransport> serverTransport
        , shared_ptr<TTransportFactory> transportFactory, shared_ptr<TProtocolFactory> protocolFactory) {

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    cout << "Start Simple Server";
    server.serve();
    cout << "End Simple Server";
}

void ThreadPoolServer(shared_ptr<TProcessor> processor, shared_ptr<TServerTransport> serverTransport
        , shared_ptr<TTransportFactory> transportFactory, shared_ptr<TProtocolFactory> protocolFactory) {
    const int workerCount = 4;
    boost::shared_ptr<ThreadManager> threadManager =
            ThreadManager::newSimpleThreadManager(workerCount);
    boost::shared_ptr<PosixThreadFactory> threadFactory =
            boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();
    TThreadPoolServer server(processor,
            serverTransport,
            transportFactory,
            protocolFactory,
            threadManager);
    cout << "Start ThreadPool Server";
    server.serve();
    cout << "End ThreadPool Server";
}

void NonblockingServer(shared_ptr<TProcessor> processor, int port, shared_ptr<TProtocolFactory> protocolFactory) {
    const int workerCount = 4;
    boost::shared_ptr<ThreadManager> threadManager =
            ThreadManager::newSimpleThreadManager(workerCount);
    boost::shared_ptr<PosixThreadFactory> threadFactory =
            boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();
    TNonblockingServer server(processor, protocolFactory, port, threadManager);
    cout << "Start ThreadPool Server";
    server.serve();
    cout << "End ThreadPool Server";
}

class SampleServer : public ServerApplication {
public:

    SampleServer() : _helpRequested(false) {
    }

    ~SampleServer() {
    }

protected:

    void initialize(Application& self) {
        loadConfiguration(); // load default configuration files, if present
        ServerApplication::initialize(self);
        logger().information("starting up"); // root logger
    }

    void uninitialize() {
        logger().information("shutting down");
        ServerApplication::uninitialize();
    }

    void defineOptions(OptionSet& options) {
        ServerApplication::defineOptions(options);

        options.addOption(
                Option("help", "h", "display help information on command line arguments")
                .required(false)
                .repeatable(false)
                .callback(OptionCallback<SampleServer>(this, &SampleServer::handleHelp)));

        options.addOption(
                Option("define", "D", "define a configuration property")
                .required(false)
                .repeatable(true)
                .argument("name=value")
                .callback(OptionCallback<SampleServer>(this, &SampleServer::handleDefine)));

        options.addOption(
                Option("config-file", "f", "load configuration data from a file")
                .required(false)
                .repeatable(true)
                .argument("file")
                .callback(OptionCallback<SampleServer>(this, &SampleServer::handleConfig)));

        options.addOption(
                Option("bind", "b", "bind option value to test.property")
                .required(false)
                .repeatable(false)
                .argument("value")
                .binding("test.property"));
    }

    void handleHelp(const std::string& name, const std::string& value) {
        _helpRequested = true;
        displayHelp();
        stopOptionsProcessing();
    }

    void handleDefine(const std::string& name, const std::string& value) {
        defineProperty(value);
    }

    void handleConfig(const std::string& name, const std::string& value) {
        loadConfiguration(value);
    }

    void defineProperty(const std::string& def) {
        std::string name;
        std::string value;
        std::string::size_type pos = def.find('=');
        if (pos != std::string::npos) {
            name.assign(def, 0, pos);
            value.assign(def, pos + 1, def.length() - pos);
        } else name = def;
        config().setString(name, value);
    }

    void displayHelp() {
        HelpFormatter helpFormatter(options());
        helpFormatter.setCommand(commandName());
        helpFormatter.setUsage("OPTIONS");
        helpFormatter.setHeader("A sample server application that demonstrates some of the features of the Util::ServerApplication class.");
        helpFormatter.format(std::cout);
    }

    int main(const ArgVec& args) {
        if (!_helpRequested) {

            Application& app = Application::instance();
            Application::instance().logger().information("Running server... " + DateTimeFormatter::format(app.uptime()));
            int port = 9090;
            shared_ptr<UserServiceHandler> handler(new UserServiceHandler());
            shared_ptr<TProcessor> processor(new UserServiceProcessor(handler));
            shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
            shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
            shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
            // SimpleServer(processor,serverTransport,transportFactory,protocolFactory);
            //ThreadPoolServer(processor,serverTransport,transportFactory,protocolFactory);
            NonblockingServer(processor, port, protocolFactory);
        }
        return Application::EXIT_OK;
    }

private:
    bool _helpRequested;
};
POCO_SERVER_MAIN(SampleServer)


